Negli ultimi anni, la sicurezza informatica è diventata una priorità per aziende, governi e sviluppatori, complice la crescente sofisticazione degli attacchi e delle vulnerabilità software. La maggior parte di questi problemi origina da una erronea gestione della memoria \cite{MemoryProblems}, ma non è l'unica causa. Anche la gestione della concorrenza, la misconfigurazione di sistemi o gli errori logici di programmazione possono portare a malfunzionamenti che a volte generano ``solo'' perdite economiche \cite{WikiCrowdStrike}, a volte possono portare alla perdita di vite umane \cite{Therac-25}.


Il software è ormai parte integrante di quasi tutte le attività umane ed alcune di esse possono descriversi come ``safety-critical'' ovvero dove la sicurezza del corretto funzionamento del codice (anche in caso di situazioni eccezionali) deve essere garantita. Tra queste attività troviamo sicuramente tutte quelle che coinvolgono l'ambito avionico, automotive, biomedicale perché possono avere ripercussioni dirette sulla salute. Per lo sviluppo di questa tipologia di software vi sono linguaggi, tecniche di programmazione e software di supporto ad-hoc.


Ovviamente non tutti i tipi di software hanno questi requisiti stringenti di correttezza, come quelli relativi al mondo videoludico, al mondo della Data Science per citarne alcuni. Tuttavia errori in entrambe queste categorie possono portare ad ingenti perdite di denaro, per motivi diversi \cite{NintendoLooseMoney} \cite{LondonWhale}. 


In generale non è sempre possibile scegliere un linguaggio di programmazione che offre funzionalità volte alla gestione della memoria automatica come il Garbage Collector perché esso richiede risorse computazionali che in certi ambiti non sono disponibili e inoltre rende impossibile determinare il tempo entro il quale certe operazioni vengono verranno effettuate (requisito fondamentale dei sistemi real-time). Sono comunque disponibili diverse soluzioni che verranno trattate in questo documento.

%sia in applicazioni più generali, come browser, sistemi operativi e infrastrutture cloud.

%Nei sistemi safety-critical, dove il software deve rispettare requisiti stringenti di affidabilità e prevedibilità, l’uso di linguaggi con garbage collector è spesso sconsigliato per via dell’imprevedibilità nella gestione della memoria. Tuttavia, anche nei sistemi non safety-critical, l’assenza di protezioni integrate nei linguaggi tradizionali come C e C++ rende il codice vulnerabile a exploit come buffer overflow e use-after-free, ampiamente sfruttati per eseguire codice malevolo o compromettere l’integrità dei dati. Inoltre, molti linguaggi non offrono strumenti efficaci per gestire la concorrenza, esponendo il software a problemi come race conditions e deadlock.

%Per affrontare queste criticità esistono diverse soluzioni. Una strategia diffusa è l’adozione di analizzatori statici, strumenti che aiutano a individuare vulnerabilità nel codice scritto in linguaggi memory-unsafe. Un’altra possibilità è l’uso di sottoinsiemi sicuri di linguaggi tradizionali, che limitano l’uso di funzionalità pericolose mantenendo la compatibilità con il codice esistente. Infine, la soluzione più radicale è l’adozione di linguaggi memory-safe, progettati per prevenire automaticamente molti errori comuni.

%Tra questi, Rust rappresenta una delle alternative più promettenti. Grazie al suo sistema di ownership, Rust garantisce memory safety senza bisogno di un garbage collector, eliminando vulnerabilità come null pointer dereference o use-after-free già in fase di compilazione. Inoltre, le sue funzionalità avanzate per la gestione della concorrenza riducono il rischio di condizioni di gara e altri errori difficili da individuare. Per queste ragioni, Rust sta emergendo come una soluzione efficace sia per applicazioni safety-critical che per software di uso generale, combinando sicurezza, efficienza e prevedibilità